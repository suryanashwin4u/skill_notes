              LARAVEL FRAMEWORK SHORT NOTES
================================================================
                  SOME BASIC NAME CONVENTIONS:
================================================================
functions 
==> userDetails()
controller
==> FetchController.php
model 
==> Home.php,FetchModel.php
blade 
==> show_user_details.blade.php
js 
==> show_users.js
route name 
==> update_pro_name
route url 
==> update-pro-name
================================================================
                    SOME BASIC COMMANDS:
================================================================
set it to true to show debugbar in the running project in the .env file
==>DEBUGBAR_ENABLED=true

clear laravel project cache
==>php artisan optimize:clear

check version of laravel framework installed in the systems
==>php artisan --version

check version of composer installed in the systems
==>composer

to create a new laravel project:
==>composer create-project laravel/laravel project_name   (for latest laravel version)

start laravel app at local server
==>php artisan serve

==>laravel development server will start at localhost:8000

to generate application key to secure session and other encrypted data
==>php artisan key:generate

to rename the laravel application name
==>php artisan app:name "new name"

to start maintainence mode
==>php artisan down

to stop maintainence mode
==>php artisan up

to print component output using component name
==><x-header componentName="nameofcomponent">

create a middleware with some addition functions
==>php artisan make:middleware nameofmiddleware --plain

==>application key can be seen inside .env file
================================================================
                            COMPOSER:
================================================================

Following are some important commands used in Composer:
1.The require command is used to add the libraries or packages as a parameter to the file composer.json, and then install it.
2.The install command is used to install all the libraries or packages from the composer.json file. This command is used to download all the PHP dependency repositories from the composer.json file.
3.The update command is used to update all the libraries or packages from the composer.json file based on the versions mentioned in the composer.json file.
4.The remove command is used to uninstall the library or package and remove it from the composer.json file.

================================================================
                    LARAVEL DIRECTORY STRUCTURE:
================================================================
1.APP directory

The App folder contains the following sub-folders:
1.Console = contains the artisan commands.
2.Exceptions = contains handle.php that handles all the exceptions.
3.Http = It has sub-folders such as controllers, middleware, and requests.
4.Providers = contain all the service providers that are required to register events for core servers and provides configuration for Laravel application.
------------------------------------------------------------
2.BOOTSTRAP directory

holds the files that are required to bootstrap or load the Laravel application and to configure auto-loading. 
The bootstrap folder contains a sub-folder cache used for caching a web application. 
It also contains the file app.php that initializes the scripts required for bootstrap.
------------------------------------------------------------
3.CONFIG directory

contains the various configuration files
------------------------------------------------------------
4.DATABASE directory

database directory consists of three sub-folders:
1.FACTORIES: The factories folder is used to generate a huge number of data records.
2.MIGRATION: The migrations folder is used to migrate the database in web application.
3.SEEDS: The seeds folder contains the classes used to perform unit testing database.
------------------------------------------------------------
5.PUBLIC directory

contains the front controllers used for initializing the Laravel web application

Following are the sub-folders of a public directory:
1. .HTACCESS: It is used for the server configuration.
2. JS and CSS: These files are considered as the main assets of a web application.
3. INDEX.php: This file is used for initializing the web application.
------------------------------------------------------------
6.RESOURCE directory

used to enhance the web application.

It contains the following sub-folders:
1. ASSETS: This folder contains the files such as LESS and SCSS used for styling the web application.
2. LANG: The lang folder provides configuration for localization or internationalization.
3. VIEWS: The views folder contains html files used to interact with the end-users.
------------------------------------------------------------
7.STORAGE Directory

contains those files which are required frequently when a Laravel project is running.

It contains the following folders:

1. APP: It contains the files which are called frequently.
2. FRAMEWORK: It contains templates, filed based sessions, and file cache.
3. LOGS: This folder tracks the exceptions and error logs.

------------------------------------------------------------
8.TEST directory

holds all the automated unit test cases

------------------------------------------------------------
9.VENDOR directory

contains the composer dependencies

============================================================

The route/web.php directory contains the definition of route files for your web interface. 

The routes in web.php are assigned with the web middleware group that provides the features like session state and CSRF protection. 

The routes defined in routes/api.php are assigned with the API middleware group, and they are stateless.

The routes defined in the routes/web.php can be accessed by entering the defined URL to the browser.

Route is the class which defines the static method get(). 

<?php  
Route::get('/', function ()  
 {      
return view ('welcome');  //return welcome.blade.php
});  

<?php  
Route::get('/example', function ()  
 {      
return "Hello javaTpoint"; //return text on screen
});  

CSRF Protection
The HTML forms that are pointing to Post, Put or Delete routes defined in the web route files should include CSRF token field. 
If the CSRF token field is not included, then the request will be rejected.

In blade file:
<form method="POST" action="/profile">  
    @csrf  or {{csrf_field()}}
    ...  
</form>  
In Controller:
class formcontroller extends controller{
  function get_form_data(Request $req){
    return $req->input(); or dd($request->all());  //to return form data in json format data with csrf token
  }
}

The Route Class contains some functions that can respond to the following http verbs:

Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

it can handle only get or post request
Route::match(['get', 'post'], '/', function () {  
//  
}); 

it can handle any http request
Route::any('/', function ()   
{  
//  
}) 

redirect any url request
<?php  
Route::get('hello', function () {  
    return redirect('/');  
})  


<?php  
Route::redirect('hello','/');             //redirect directly using url request
Route::redirect('/here', '/there');     

==>By default, Route::redirect returns a 302 status code.

to return a 301 status code:
Route::redirect('/here', '/there', 301);  //manually set status code
or
Route::permanentRedirect('/here', '/there');

Route::view('/','welcome');  
Route::view('/welcome', 'welcome');
Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

//pass url parameters to the callback functions
Route::get('/post/{id}/{name}', function($id,$name)  
{  
  return "id number is : ". $id ." ".$name;   
});  

//pass optional parameters to callback functions
Route::get('user/{name?}', function ($name=null) {  
    return $name;  
});  

//pass the url parameters with some regular expressions
Route::get('user/{id}/{name}', function ($id,$name) {  
    return "id is : ". $id ." ,".  "Name is : ".$name ;  
})->where(['id'=>'[0-9]+', 'name'=>'[a-zA-Z]+']);  

The 'where' method accepts the name of the parameter and regular expression constraint that defines how the parameter should be constrained.

//request filter using predefined helper functions in route class
Route::get('/user/{id}/{name}', function ($id, $name) {
})->whereNumber('id')->whereAlpha('name');

Route::get('/user/{name}', function ($name) {
    //
})->whereAlphaNumeric('name');

Global Constraints are used when we have multiple routes, 
and the same constraints are applied to all the routes.
define these patterns in the boot method of your RouteServiceProvider.

public function boot()  
{  
Route::pattern('id', '[0-9]+');  
parent::boot();  
}  

Named Routes
Route::get('student/details', function()  
{  
    //  
}) -> name('student_details'); 
or
Route::get('student/details', 'studentcontroller@showdetails') -> name('student_details');


//Generating URLs  
$url= route('student_details');  

//Generating Redirects using route names
return redirect() -> route('student_details');  

//naming using as
Route::get('student/details/example',array   
('as'=>'student.details',function()  
{  
   $url=route('student.details');  
   return "The url is : " .$url;  
}));  

to know route lists
==>php artisan route:list

Note:The benefit of using named routes is that if we change the location of the route,
then also the link will work or we can say that it is beneficial for changing the URLs dynamically.

Route::get('user/{id}/profile',function($id)  
{  
   $url = route('profile',['id'=>100]);  
    return $url;  
})->name('profile');  

Navigating from one route to another using named routes
<a href="{{ route('student.details') }}">Student</a>  

Middleware acts as a layer between the user and the request. 
located in the app/Http/Middleware directory.

Creating a middleware
==>php artisan make:middleware 'name of the middleware'.

Apply a Middleware ,Open the kernel.php file. 
1.to all the URLs.
==>protected $middleware = []

2.to some specific routes
==>protected $routeMiddleware = []

3. Open the kernel.php file. If we want to apply group of middlewares at a time 
==>protected $middlewareGroups = []

Add the middleware code in the web.php file.
Route::Get('/{age}',function($age)  
{  
  return view('welcome');  
})-> middleware('age');  

public function handle($request, Closure $next){  
  //return "middleware";  
if($request->age>10)  
{  
echo "Age is greater than 10";  
}  
else  
{  
echo"Age is not greater than 10";  
}  
return $next($request);       
}}

Route Groups is an essential feature in Laravel, which allows you to group all the routes. 
Routes Groups are beneficial when you want to apply the attributes to all the routes. 
If you use route groups, you do not have to apply the attributes individually to each route; this avoids duplication. 
It allows you to share the attributes such as middleware or namespaces, without defining these attributes on each individual route.

Route::group( [ ] , callback_function);  

Route::group([], function()  
{  
   Route::get('/first',function()  
 {  
   echo "first route";  
 });  
Route::get('/second',function()  
 {  
   echo "second route";  
 });  
Route::get('/third',function()  
 {  
   echo "third route";  
 });  
});  


Path prefixes are used when we want to provide a common URL structure.
Route::group(['prefix' => 'tutorial'], function()  
{  
   Route::get('/aws',function()  
 {  
   echo "aws tutorial";  
 });  
Route::get('/jira',function()  
 {  
   echo "jira tutorial";  
 });  
Route::get('/testng',function()  
 {  
   echo "testng tutorial";  
 });  
});  


We can also assign middleware to all the routes within a group.

Route::middleware(['age'])->group(function(){    
    Route::get('/aws',function(){  
      echo "aws tutorial";  
    });  
    Route::get('/jira',function(){
      echo "jira tutorial";  
    });  
    Route::get('/testng',function(){  
      echo "testng tutorial";  
    });  
});  


The name method is used to prefix each route name with some specified string

Route::name('admin.')->group(function()  
{  
   Route::get('users', function()  
{  
 return "admin.users";  
})->name('users');  
});  


Controllers are used to handle the request logic within the single class, and the controllers are defined in the "app/http/Controllers" directory
php artisan make:Controller PostsController


php artisan make:controller --resource PostController (predefined functions)

1.create(): It is used to create a new resource.

2.store(): It is used to store the specified resource.

3.update(): It is used to update the specified resource in the storage.

4.destroy(): It is used to remove the specified resources from the storage.

routing controller==>Route::get('/post','PostController@index');  

passing data to controller:
Route::get('/post/{id}','PostController@index');

public function index($id)  
{  
    return "ID is :". $id;  
}  


As RouteServiceProvider loads all the route files that contain the namespace, we just need to specify the class name that comes after the App/Http/Controllers portion of the namespace.
Route::get('\post','Post\PostController@index');


If we want to use the single method in a controller, then we can use the single __invoke() method on the controller.
route::get('/post/{id}','PostController');  
class PostController extends Controller  
{  
    //  
 public function __invoke($id)  
{  
  return "id is : ". $id;  
}  
}  
This concludes that we do not need to write the @invoke method for accessing the single action controllers.

If no action is specified, i.e., we forget to write the __invoke() method, then the UnexpectedValueExpression is thrown.


Laravel resource controllers provide the CRUD routes to the controller in a single line of code. A resource controller is used to create a controller that handles all the http requests stored by your application.

The resource() is a static function like get() method that gives access to multiple routes that we can use in a controller.

Route::resource('posts','PostController');

creating a resource controller: php  artisan make:controller PostController -resource;  

<?php  
namespace App\Http\Controllers;  
use Illuminate\Http\Request;  
class PostController extends Controller  
{  
    /** 
     * Display a listing of the resource. 
     * @return \Illuminate\Http\Response 
     */  
public function index()  
{  
          
//  
      
}  
/** 
     * Show the form for creating a new resource. 
     * @return \Illuminate\Http\Response 
       
*/  
 public function create()  
{  
          
//  
      
}  
/** 
     * Store a newly created resource in storage. 
     * 
     * @param  \Illuminate\Http\Request   $request 
     * @return \Illuminate\Http\Response 
     */  
public function store(Request $request)  
{  
          
//  
      
}  
/** 
     * Display the specified resource. 
     * @param  int  $id 
     * @return \Illuminate\Http\Response 
     */  
public function show($id)  
{  
  
  //  
}  
/** 
     * Show the form for editing the specified resource. 
     * @param  int  $id 
     * @return  \Illuminate\Http\Response 
     */  
 public function edit($id)  
      
{  
          
//  
      
}  
/** 
     * Update the specified resource in storage. 
     * @param  \Illuminate\Http\Request   $request 
     * @param  int  $id 
     * @return \Illuminate\Http\Response 
     */  
 public function update(Request $request, $id)  
{  
          
//  
      
}  
/** 
     * Remove the specified resource from storage. 
     * @param  int  $id 
     * @return  \Illuminate\Http\Response 
     */  
 public function destroy($id)  
 {  
          
//}}  


Accessing the show() method of PostController class
public function show($id)  
{  
return "show method is called and ID is : ". $id;  
}  

As we know that URI of the posts.show is posts/{posts},
'localhost/laravelproject/public/posts/58'

Accessing the create() method of PostController class
public function create()  
{  
     return "This is the create method";  
}  

As we know that the URI of the posts.create is posts/create, so the URL to access the create() method would be 'localhost/laravelproject/public/posts/create'.

We can register the routes for multiple controllers by passing an array to the resources() method.

route::resources(  
['posts'=>'PostController',  
'student'=>'StudentController']  
);  


Partial Resource Routes
Route::resource('student','StudentController',['only' => ['create','show']]);  

All the methods of the controller have a default route name, but Laravel allows you to override the route names by passing name array. Name array contains the name of the routes that you want to specify of your choice.

Route::resource('student', 'StudentController',['names' => ['create' =>'student.build']]);  

======================================================
                  laravel forms
======================================================

install a html package from composer
==>$composer require "laravelcollective/html":"^5.4.0"  

open the config/app directory in your project and add the html provider in the providers array of the config/app.php file.

we add the two class aliases to the aliases array of the config/app.php file.
'aliases' => [  
              'Form' => Illuminate\Html\FormFacade::class,  
              'Html' => Illuminate\Html\HtmlFacade::class,   
             ],  

Opening a Form
==>
Form::open(['url' => 'post/create'])  
//  
//
//
Form::close()

In laravel forms, the default method is assumed to be 'post' method
==>Form::open(['url'=>'Post/create , 'method'=>'Put''])
or
==>Form.open(['route' => 'route.name'])  
or
==>Form.open(['action' => 'Controller@method' , 'method'=>'POST' ])  

The syntax for writing a label element in Laravel is given below:
==>Form::label('phone_no', 'Phone Number',['class'=>'phone_no']);

The syntax for generating a text area in Laravel is given below:
==>Form::text('email');
or
We can also specify the default value to the text box.
==>Form::text('email','akshita123@gmail.com');

The syntax for the password field is given below:
==>Form::password('password',['class'=>'pass']);

We can create the checkbox as given below:
==>Form::checkbox('name','value');

By default, the checkbox is unchecked. We can also check the box by providing true value to the checkbox element.
==>Form::checkbox('name','value',true);

We can create the radio button as given below:
==>Form::radio('name','value');

By default, the radio button is not selected. We can also select the radio button by providing true value to the radio button element.
==>Form::radio(''name','value',true);

We can also add the number input field in a form.
==>Form::number('name','value');

Syntax for file input field is given below:
==>Form::file('image');

The syntax for creating a drop-down menu is given below:
==>Form::select('digits', [1,2,3,4,5,6])

We can also set the drop-down list with a default value:
==>Form::select('digits',[1,2,3,4,5,6],'2')
The above code sets the value of the drop-down list with a second element of the array, i.e., 3 as indexing starts with 0.

Generating Grouped list
==>Form::select('name',[
        'fruits' => ['Apple','Mango','Orange'],
        'Vegetables' => ['Potato','Tomato','Cabbage'],
])

Generating drop-down list with a range.
==>Form::selectRange('number',1,30)

Generating drop-down list with a month names.
==>Form.selectMonth('month')

The syntax for generating a date input field is given below:
==>Form::date('name',\Carbon\Carbon::now())

We can also create the button in a web form by using the button field in a form.
==>Form::submit('Click me!!')

for example
==>
{!! Form::open(['route'=>'posts.store']) !!}  
    
<div class="form-group">  
{{form::label('name','Name')}}  
{{form::text('name','',['class'=>'form-control','placeholder'=>'Name'])}}  
</div>  

<div class="form-group">  
{{form::label('gender','Gender')}}  
{{form::radio('male','Male')}} Male  
{{form::radio('Female','Female')}} Female  
</div>  

<div class="form-group">  
{{form::label('profile','Profile')}}  
{{form::select('list',['Software Developer','QA Analyst','Manager','HR'])}}  
</div>  

<div class="form-group">  
{{form::label('dob','Date of Birth')}}  
{{Form::date('dob', \Carbon\Carbon::now())}}  
</div>  

<div class="form-group">  
{{form::label('skills','Skills Description')}}    
{{form::textarea('body','',['placeholder'=>'Skills Description'])}}  
</div>  

<div class="form-group">  
{{form::label('percentage','Percentage in 12th')}}  
{{form::text('percent','',['class'=>'form-control','placeholder'=>'Percentage in 12th'])}}  
</div>  

<div class="form-group">  
{{form::label('experience','Experience')}}  
{{form::number('exp','number')}}  
</div>  

<div class="form-group">  
{{form::label('expected_salary','Expected Salary')}}  
{{form::text('salary','',['placeholder'=>'Expected Salary'])}}  
</div>  
  
<div class="form-group">  
{{form::label('resume','Resume Upload')}}  
{{Form::file('resume')}}  
</div>  
  
{{Form::submit('Submit', ['class'=>'btn btn-primary'])}}  
  
{!!Form::close()!!}  
@stop  

then we make a resource controller to validate form data
==>public function store(Request $request)  
    {  
       $this->validate($request,[  
       'name'=>'required',  
       'list'=> 'required',  
       'dob'=>'required',  
       'body'=>'required',  
       'percent'=>'required',  
       'exp'=>'required',  
       'salary'=>'required',  
       'resume'=>'required']);  
           
      return "Resume has been updated successfully";      
    }  




================================================================
			                    notes
================================================================

2. composer.json file also contains details of the project
 
   "php": "^7.3|^8.0",(min. supported version | current version)

3. Axios: Axios is a Javascript library used to make HTTP requests from node.js or XMLHttpRequests from the browser and it supports the Promise API that is native to JS ES6. It can be used intercept HTTP requests and responses and enables client-side protection against XSRF. It also has the ability to cancel requests.

<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

4. laravel breeze authentication

5. faker.js to create fake data

6. 

7. dd($request); dump and die function to check requests

8. naming conventions:
	
  functions names
  ==>userDetails()
	controller
  ==>FetchController.php
	models
  ==>Home.php,FetchModal.php
	blade files
  ==>show_user_details.blade.php
	javascript files
  ==>show_users.js
	route names
  ==>update_pro_name
	route url
  ==>update-pro-name

-------------------------------------------------------
laravel codes

1.call controller function using url passing parameter

use App\Http\Controllers\ProvisionServer;
Route::get('/user/{id}', [UserController::class, 'show']);

2.passing parameters and dependency injection
Route::get('/user/{id}', function (Request $request, $id) {
    return 'User '.$id;
});


------------------------------------------------------
to use php variable inside js to convert array into json format into view
0.<script>
    var data = @json($data);
    console.log(data[0]);
  </script>

1.@extends( 'home' )===>

2.@section('pageTitle')===>
	{{ 'Enquiry' }}===>
  @endsection===>
		
  @section( 'addtional_css' )===>
	
  @section('content')===>

3.href="{{ asset('https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css')}}"===>
  href="{{ asset('css/new_css/add-enquiry.css')}}"===>

4.@parent===>

5.@append====>

6.href="{{route('enquiry')}}"===>to route using route name

7.@include('enquiry.add.personal')===>to include blade files into current view

8.token: "{{ csrf_token() }}"===>auto generate csrf token for form

9.fetchCountries: "{{ url('fetchCountries') }}"===>

10.pathToEmailAttachment: "{{ asset('uploads/emailtemplate/') }}"===>to add css,js etc files

11.var broadAndNarrowId = {!! json_encode($broadAndNarrowId) !!};===>

12.$('.passport-div-open1, .passport_tentative_date,.passport_tentative_date1  ').hide();===>

13.$("#state_id").append("<option value=\"" + "" + "\">" + "" + "</option>");===>

14.<script src="{{ asset('js/theia-sticky-sidebar.js')}}"></script>===>

15.$('[data-toggle="tooltip"]').tooltip();==>

16.<script>
  $(function () {
    setTimeout(function () {
        var header_height = $("header").height() + 50;
        //  console.log(header_height);
        $(".fixed-scroll-div").length > 0 &&
            $(".fixed-scroll-div").parent().theiaStickySidebar({
                updateSidebarHeight: !0,
                additionalMarginTop: header_height,
            });
    }, 200);
  });
</script>


17.function scrollToAnchor(aid) {
  var aTag = $("a[name='" + aid + "']");
  $('html,body').animate({
    scrollTop: aTag.offset().top - 110
  }, 'slow');
}

$("#1").click(function() {
  scrollToAnchor('perinfo');
});


18. {{ Form::select('marital_status',config('sc_common.marital_status'), isset($personalDetail['marital_status']) ?$personalDetail['marital_status'] : null, ['id' => 'marital_status','class'=>'form-control select2']) }}

{{Form::select('mobile_code',$phoneCode,91, ['class'=>'form-control ISD_code select2','id'=>'mobile_code','placeholder'=>''])}}

{{Form::select('whatsup_no_code',$phoneCode,91, ['class'=>'form-control ISD_code select2','id'=>'whatsup_mobile_code','placeholder'=>''])}}

{{Form::select('secondary_mobile_code',$phoneCode,91, ['class'=>'form-control ISD_code select2','placeholder'=>''])}}

{{Form::select('country_live_in',$allCountry,101, ['class'=>'form-control select2','id'=>'country_id','placeholder'=>'','onchange'=>'get_addStateName();'])}}

{{Form::select('state_id',$indianState,null, ['class'=>'form-control select2','id'=>'state_id','onchange'=>"get_addCityName()"])}}


19. value="{{ isset($spouse['marriage_date'])?$spouse['marriage_date']:null }}"

20. $('#marriage_date').datepick({
        dateFormat: 'dd-mm-yyyy',
        maxDate: 0,
    });

21.onkeypress="return isNumberKey(event)

22.


---------------------------------------------------------
			blade template note

//to print variable value in the template view
{{$variable}};  

//to print variable value after checking exsistence
{{ $variable or 'default value'}}  

//check if a variable has value
@isset($a)
  template code
@endisset


@if(($id)==1)  
student id is equal to 1.  
@else  
student id is not equal to 1  
@endif  


@unless($id==1)  
student id is not equal to 1.  
@endunless  


@hasSection('title')  
 @yield('title') - App Name  
 @else  
 Name  
@endif  



@for($i=1;$i<11;$i++)  
{{$i}}  
@endfor  


@forelse($students as $student)  
{{$student}}<br>
@empty
No Record Found  
@endforelse  



@foreach($students as $student)  
{{$student}}<br>  
@endforeach  


@while(($i)<5)  
javatpoint  
{{$i++}}  
@endwhile  



@yield('content')  
@yield('footer') 

@extends('layout.master')  

@section('content')  
<h1>Contact Page </h1>   
@stop  

@section('footer')  
<script> alert("Hello JavaTpoint") </script>      
@stop 

@extends('layout.master')  
@section('content')  
<h1>Post Page:</h1>  
<h2>id is :{{$id}}<br> Password is :{{$password}}<br>Name is : {{$name}}</h2>  
@stop  

@extends('layout.master')  
@section('content')  
<h1>Contact Page</h1>  
@stop   
@section('footer')  
@parent  
<p>this is appended</p>  
@stop  

to push to named stacks which can be rendered somewhere else in another view or layout.
@push('scripts')
    <script src="/example.js"></script>
@endpush



The use of @parent directive is to display the content of the section defined in the master layout.

=======================================================================
                    migration files functions
=======================================================================

  public function up()  
    {  
            Schema::create('users', function (Blueprint $table) {  
            $table->bigIncrements('id');  
            $table->string('name');  
            $table->string('email')->unique();  
            $table->timestamp('email_verified_at')->nullable();  // value can be null if not filled
            $table->string('password');  
            $table->rememberToken();  //generate unique token id for users after login
            $table->timestamps();  //generate created_at and updated_at time column
        });  
    }  
  
  public function down()  
    {  
        Schema::dropIfExists('users');  
        
        //This function checks whether the 'users' table exists or not, if the 'users' exists, then it drops the users table.
    }  


up() method is used to create the new table, add the new columns or indexes to the database
down() method is the opposite of the up() method, i.e., it drops the fields. 
The above class is basically creating the table in a database. 
The up() method runs the static method, i.e., create() by using the Schema class.
The create() method contains the two parameters, i.e., the name of the table and the closure function.

$table->bigIncrements('id'): It means that the $table is implementing the increments() method which is creating the id column in users table, and this 'id' is auto-incremented.

$table->string('name'): It means that $table implements the string() method which is creating the name column in users table.

$table->string('email')->unique(): It means that $table implements the string() method which is creating the email column in users table. It also implements the unique() function which means that email should be unique.

$table->timestamp('email_verified_at')->nullable(): It means that $table implements the timestamp() method which is creating the email_verified_at column in users table. This function also creates the two columns, i.e., created_at and updated_at, and these two fields are automatically updated when new records are added or updated.

$table->integer('is_admin')->unsigned();
$table->integer('is_admin')->default('0'); 

command to create migration file
==>php artisan make:migration file_name --create="table_name" //'-create="table_name"' Is the flag that creates the table. 

<?php  
use Illuminate\Support\Facades\Schema;  
use Illuminate\Database\Schema\Blueprint;  
use Illuminate\Database\Migrations\Migration;  
class AddColumnAdminIsToTable extends Migration  
{  
    /** 
     * Run the migrations. 
     * 
     * @return void 
     */  
    public function up()  
    {  
        Schema::table('posts', function (Blueprint $table) {  
            //  
        });  
    }  
  
    /** 
     * Reverse the migrations. 
     * 
     * @return void 
     */  
    public function down()  
    {  
        Schema::table('posts', function (Blueprint $table) {  
            //  
        });  
    }  
}  

command to Add columns to the existing table using migration
==>php artisan make:migration file_name -table="table_name"   //-table="table_name" is the flag which tells the laravel that we are working on exsisting table.

command to make tables if relative path is given for a project
==>php artisan migrate --path= relative_directory_path

command to create tables into database
==>php artisan migrate 

command to rollback tables from the database
==>php artisan migrate:rollback

lists all the commands available in Laravel.
==>php artisan list


There are six commands of migrate in Laravel:
php artisan migrate ==> creates the migration table in a database.
php artisan migrate:refresh ==> rollback all the migrations and then re-run the migrations. Basically, it is used to re-create the entire tables.
php artisan migrate:reset ==> rollback all the migrations, i.e., it drops all the tables that you have created in your database.
php artisan migrate:rollback ==> rollback the last tables batch migration.
php artisan migrate:status ==> to show the status of each migration.

---------------------------------------------------------------------
		DEALING WITH DATABASE

1.Inserting the data

Route::get('/insert', function () {  
	DB::insert('insert into posts(title,body) values(?,?)',['software developer','himanshu is a software developer']);  
}); 


2.Reading the data

Route::get('/select',function(){  
	$results=DB::select('select * from posts where id=?',[1]);  
	foreach($results as $posts)  
	{  
	echo "title is :".$posts->title;  
	echo "<br>";  
	echo "body is:".$posts->body;  
	}  
	}); 

3.Updating the data

Route::get('/update', function(){  
$updated=DB::update('update posts set title="software tester" where id=?',[1]);  

if($updated)  {
echo "updated";
}else{
echo "not updated";
}
});

4.Deleting the data

Route::get('/delete',function(){  
$deleted=DB::delete('delete from posts where id=?',[2]);  
if($deleted)  {
echo "deleted";
}else{
echo "not deleted";
}
});
});  


table(),get()
$users = DB::table('users')->get();

where(),first()
$user = DB::table('users')->where('name', 'John')->first();

value()
$email = DB::table('users')->where('name', 'John')->value('email');

find()
$user = DB::table('users')->find(3);

pluck()
$titles = DB::table('users')->pluck('title');
$titles = DB::table('users')->pluck('title', 'name');

orderBy(),chunk()->it returns small chunks of data at a time
DB::table('users')->orderBy('id')->chunk(100, function ($users) {
    foreach ($users as $user) {
        //
    }
});

-------------------------------------------------------------------
			  ELOQUENT

eloquent model that allows the interaction with a database. 
Each database table has its corresponding model that provides the interaction with a database. 
The model allows you to query the data in your tables.

Models are created in the app directory

command to create the model:
==>php artisan make:model model_name

generate the model by using database migration:
==>php artisan make:model model_name -m / php artisan make:model Post -migration

Mostly model class name should be in singular format and table name should be in plural format of model class name....like class table extends Model{} --> table name in the database --> tables

if it is not then declare protected $table = 'table_name' inside model class of that table;

structure of the model class:
<?php  
namespace App;  
use Illuminate\Database\Eloquent\Model;  
class table extends Model  
{  
	protected $table = 'table_1'; // it is used when table name is different from class name else it is not necessery to declare
	protected $primaryKey = 'post_id';  
	public $incrementing = false;
	protected $keyType = 'string';	
}  

fetching all data from the table
<?php  
use App\Post;  

Route::get('/read',function(){  

$posts=model_class_name::all();  //all() method that retrieves all the records from the database

foreach($posts as $post)  
{  
  echo $post->column_name;  
}  
});  

finding data from the table

Route::get('/find',function(){  
$posts=model_class_name::find(2); 	//to retrieve only 2nd row from the database
return $posts->title;  		   

$posts=model_class_name::where('id',2)->first();  //fetch only first row where id=2
return $posts;  

$posts=model_class_name::where('id',1)->value('column_name');  //to retrieve the value of a column directly.
return $posts;  

});  

pluck() method
==>used to retrieve a list of specific values from a given $array. 
It is most useful when used against arrays of objects, but will also work with arrays just as well.
for example:
$country = Country::where('is_active', 1)->pluck('country_name', 'id');

inserting data into database

Route::get('/insert',function(){
$post=new model_class_name;  
$post->column_name_1='Nishka';      //inserting into column_name_1
$post->column_name_2='QA Analyst';  //inserting into column_name_2
$post->save();  		    //to insert data
});  


Route::get('/basicupdate',function(){  
$post=model_class_name::find(2);    	//find 2nd row		   
$post->column_name_1='Haseena';     	//change column value of that row 	
$post->column_name_2='Graphic Designer';//change column value of that row
$post->save();  			//to update data
});  

MASS ASSIGNMENT

Route::get('/create',function(){  
Post::create(['column_name_1'=>'Harshita','column_name_2'=>'Technical Content Writer']);  
});  

To provide the mass assignment, we need to add the $fillable attribute in a model class
<?php  
namespace App;  
use Illuminate\Database\Eloquent\Model;  
class Post extends Model  
{  
    //  
protected $table='posts';  
protected $primaryKey='id';  
protected $fillable=  
[  
'column_name_1',  
'column_name_2'  
];  
}  

mass updating data through eloquent
Route::get('/update',function(){  
model_class_name::where('id',1)->update(['column_name_1'=>'Charu','column_name_2'=>'technical Content Writer']);  
});  

delete data after finding through eloquent
Route::get('/delete',function(){  
$post=model_class_name::find(1);  
$post->delete();  		//delete row after finding
});  


Route::get('/destroy',function(){  
model_class_name::destroy(2);  //direct delete 2nd row
});  


Route::get('/destroy',function(){  
Post::destroy([3,4]);  	       //delete 3rd,4th row directly
});


Route::get('/delete1',function(){  
Post::where('id',5)->delete();  //delete using query
});  

Soft Deleting/Trashing
In soft deleting, records are not permanently deleted; they are stored in the trash space.

First, we need to set the deleted_at attribute to the model class.
<?php  
namespace App;  
use Illuminate\Database\Eloquent\Model;  
use Illuminate\Database\Eloquent\SoftDeletes;  
class Post extends Model  
{  
 use SoftDeletes;  
protected $table='posts';  
protected $primaryKey='id';  
protected $dates=['deleted_at'];  
}  

Now, make migration to add a deleted_at column in the posts table.
php artisan make:migration migration_name --table=table_name


<?php  
use Illuminate\Support\Facades\Schema;  
use Illuminate\Database\Schema\Blueprint;  
use Illuminate\Database\Migrations\Migration;  
  
class AddColumnDeletedAt extends Migration  
{  
    /** 
     * Run the migrations. 
     * 
     * @return void 
     */  
    public function up()  
    {  
        Schema::table('posts', function (Blueprint $table) {  
            $table->softDeletes();  
        });  
    }  
  
    /** 
     * Reverse the migrations. 
     * 
     * @return void 
     */  
    public function down()  
    {  
        Schema::table('posts', function (Blueprint $table) {  
            $table->dropColumn('deleted_at');  
        });  
    }  
}  

The laravel contains the helper method known as softDeletes(), which we have used in the above code. 
The softDeletes() method is used to create the column.

Now, run the command php artisan migrate.

Route::get('/softdelete',function(){  
Post::find(1)->delete();  
});  

we are softdeleting the record

To retrieve the deleted data, we use the withTrashed() method:
Route::get('/readsofdelete',function(){  
$post=model_class_name::withTrashed()->where('id',1)->get();  
return $post;  
});  

Restoring deleted/trashed data:
Route::get('/restore',function(){  
Post::withTrashed()->where('id',1)->restore();  
});  

Deleting records permanently:
Route::get('/forcedelete',function(){  
Post::onlyTrashed()->forceDelete();  
}); 

Laravel Tinker allows you to interact with a database without creating the routes. Laravel tinker is used with a php artisan to create the objects or modify the data. The php artisan is a command-line interface that is available with a Laravel. Tinker is a command tool that works with a php artisan. A tinker plays around the database means that it allows you to create the objects, insert the data, etc.

To enter the Tinker environment, run the command given below:
==>php artisan tinker

inserts the data directly in the database table:
==>$post=App\Post::create(['title'=>'Akshay','body'=>'akshay is a software developer'])

We can retrieve the records from the database in three ways:

The first way is to use the find() method.
==>$post=App\Post::find(1)

The second way is to use the constraint, i.e., where clause.
==>$post=App\Post::where('id',1)->first()

==>$post=App\Post::where('id','>',1)->get()

The third way is to use whereId().
==>$post=App\Post::whereId(1)->first()

Updating data
==>$post=App\Post::find(1)
==>$post->title='Akshay'
==>$post->save()='Akshay'

Deleting data
==>$post->delete()

To delete the record permanently
==>$post->onlyTrashed()

To delete the trashed record permanently
==>$post->forceDelete()

==========================================
              crm notes

1.php carbon class has some predefined functions for time formating
this code will convert string to date using parse method, find difference between both date and convert into years
{{ \Carbon\Carbon::parse($applicantData->date_of_birth)->diff(\Carbon\Carbon::now())->format('%y years') }}

2.config('app.url')
it will go to config file and check for url variable and return env url value from env file if available

3.env('APP_URL', 'http://localhost')
it will return APP_URL value from env file but if it is not available in env value then it will return value as passed in above function as 2nd argument

4.explode(',' , string_variable)
it will break string as per separater passed as first argument in the above function and return array

5.end(pass_array)
return last element of an array

6.except(['name'])
returns collection array except name key

7.array_keys(array)
returns array keys 

8.array_search("value",array)
return key of value in array

9.The firstOrNew method is really useful for finding the first Model that matches some constraints or making a new one if there isn’t one that matches those constraints.
$user = User::firstOrNew(['email' =>  request('email')]);
You may also pass an array of additional attributes to set as the second parameter if no existing Model is found:
$user = User::firstOrNew(
    ['email' =>  request('email')],
    ['name' => request('name')]
);

10.The firstOrCreate method is very similar to the firstOrNew method. It tries to find a model matching the attributes you pass in the first parameter. If a model is not found, it automatically creates and saves a new Model after applying any attributes passed in the second parameter
$user = User::firstOrCreate(
    ['email' =>  request('email')],
    ['name' => request('name')]
);

11. The firstOr method retrieves the first Model from a query, or if no matching Model is found, it will call a callback passed.
$user = User::where('email', request('email'))->firstOr(function () {
    $account = Account::create([ //... ]);
 
    return User::create([
        'account_id' => $account->id,
        'email' => request('email'),
    ]);
});


12.The updateOrCreate method attempts to find a Model matching the constraints passed as the first parameter. If a matching Model is found, it will update the match with the attributes passed as the second parameter. If no matching Model is found a new Model will be created with both the constraints passed as the first parameter and the attributes passed as the second parameter.
$user = User::updateOrCreate(
    ['email' =>  request('email')],
    ['name' => request('name')]
);

13.
Carbon::parse($request->gicDate)->format('Y-m-d H:i:s') : ''

14. back to previous route
==> return back();

15. this will produce full url with given route
==> url("/posts/{$post->id}");




=================================================================
                    LARAVEL EXCEL package IMPORT
=================================================================

1. first install laravel excel package
==> composer require maatwebsite/excel

2. add into config/app.php providers array
==> Maatwebsite\Excel\ExcelServiceProvider::class,

3. add it in aliases in config/app.php aliases array
==> 'Excel' => Maatwebsite\Excel\Facades\Excel::class,

4. To publish the config, run the vendor publish command:
==> php artisan vendor:publish --provider="Maatwebsite\Excel\ExcelServiceProvider" --tag=config


5. make a model suiting table name in the database
==>php artisan make:model model_name 

6. make an import class which will be created inside app\imports with the same name as given below
==>php artisan make:import modelnameImport --model=modelname

7.make changes inside the import class 
==> public function model(array $row)
    {
        return new employee([
     //enter columns name like this       
            'name'     => $row[name],
            'email'    => $row[email], 
            'phone'    => $row[phone], 
            'salary'    => $row[salary], 
            'department'    => $row[department],

        ]);
    }

8. add other classes like and use it in existing import class:
==> use Maatwebsite\Excel\Concerns\WithHeadingRow;
==> class employeeImport implements ToModel,WithHeadingRow

9.create controller
==> public function importExcelFile() 
    {

            return view('import-form');
       
    }

    public function import(Request $request) 
    {
       
        Excel::import(new employeeImport, $request->file);
        return "records imported successfully";
    }
10.make a form in the view
==> <form method="post" enctype="multipart/form-data" action={{route('employee.import')}} >
            @csrf
            <input type="file" name="file">
            <button>submit</button>
        </form>

11.create route
==> Route::get('/import-form', [EmployeeController::class,'importExcelFile']);
    Route::post('/import', [EmployeeController::class,'import'])->name('employee.import');


//if any db query fails then it rollbacks all db requests
use DB::transactions(function(){
});


//return array directly
return  [CourseBroadField::whereIsActive(1)->where('id','!=',$request->id)->get(['id','broad_field_name'])];

//return json
return response()->json(['status' => 'success', 'msg' => 'Course cloned successfully']);




//to create import class for excel upload
php artisan make:import UpdateCourseLinkImport






















