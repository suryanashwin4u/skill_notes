laravel short notes
-------------------------
Laravel is a PHP framework that uses the MVC architecture.

where,

Framework: It is the collection of methods, classes, or files that the programmer uses, and they can also extend its functionality by using their code.
Architecture: It is the specific design pattern that the framework follows. Laravel is following the MVC architecture.

M: 'M' stands for Model. A model is a class that deals with a database.
V: 'V' stands for View. A view is a class that deals with an HTML
C: 'C' stands for Controller. A controller is the middle-man that deals with both model and view. A controller is the class that retrieves the data from the model and sends the data to the view class.

Following are some advantages of Laravel:
1.Creating authorization and authentication systems
2.Integration with tools
Laravel is integrated with some popular cache back ends such as Redis, and Memcached.
3.Mail service integration
4.Handling exception and configuration error
5.Automation testing work
6.Separation of business logic code from presentation code
7.Fixing most common technical vulnerabilities
An American organization, i.e., OWASP Foundation, defines the most important security vulnerabilities such as SQL injection, cross-site request forgery, cross-site scripting, etc.
8.Scheduling tasks configuration and management

Following are the features of Laravel:
1.Authentication
2.Innovative Template Engine
3.Effective ORM
4.MVC Architecture Support
5.Secure Migration System
6.Unique Unit-testing
7.Intact Security
It uses "Bcrypt Hashing Algorithm" to generate the salted password means that the password is saved as an encrypted password in a database, not in the form of a plain text.
8.Libraries and Modular
9.Artisan
Artisan also allows the developers to create their own commands.

What is Composer?
Composer is a dependency manager for a PHP programming language that manages the dependencies of PHP software and required libraries

Composer runs through the command line. The main purpose of the composer is to install the dependencies or libraries for an application. The composer also provides the users to install the PHP applications available on the Packagist, where Packagist is the main repository that contains all the available packages.

Following are some important commands used in Composer:
1.The require command is used to add the libraries or packages as a parameter to the file composer.json, and then install it.
2.The install command is used to install all the libraries or packages from the composer.json file. This command is used to download all the PHP dependency repositories from the composer.json file.
3.The update command is used to update all the libraries or packages from the composer.json file based on the versions mentioned in the composer.json file.
4.The remove command is used to uninstall the library or package and remove it from the composer.json file.

check whether the composer is installed successfully or not. To check this, open the command prompt and type Composer then press enter.

command to create a new laravel project:
-->composer create-project laravel/laravel project_name   (for latest laravel version)
or
-->composer create-project ?prefer-dist laravel/laravel project_name 5.2.29  (for old laravel versions)

laravel directory structure
-------------------------------
app directory

The App folder contains the following sub-folders:

1.Console = Console folder contains the artisan commands required for Laravel.
2.Exceptions = Exceptions folder contains the various exception handlers.The Exceptions directory contains the file handle.php that handles all the exceptions.
3.Http = It has sub-folders such as controllers, middleware, and requests.
3.1 middleware = It provides a filter mechanism and communication between request and response.
3.2 Requests = includes all the requests of an application.
4.Providers =contain all the service providers that are required to register events for core servers and provides configuration for Laravel application.


bootstrap directory
holds the files that are required to bootstrap the Laravel application and to configure auto-loading. The bootstrap folder contains a sub-folder cache used for caching a web application. It also contains the file app.php that initializes the scripts required for bootstrap.

config directory
contains the various configuration files

Database directory
holds the database files.

database directory consists of three sub-folders:
1.Factories: The factories folder is used to generate a huge number of data records.
2.Migrations: The migrations folder is used to migrate the database in web application.
3.Seeds: The seeds folder contains the classes used to perform unit testing database.

Public directory
contains the front controllers used for initializing the Laravel web application

Following are the sub-folders of a public directory:
1. .htaaccess: It is used for the server configuration.
2. Javascript and CSS: These files are considered as the main assets of a web application.
3. index.php: This file is used for initializing the web application.

Resource directory
used to enhance the web application. It contains the following sub-folders:

1. Assets: This folder contains the files such as LESS and SCSS used for styling the web application.
2. Lang: The lang folder provides configuration for localization or internationalization.
3. Views: The views folder contains html files used to interact with the end-users


Storage Directory
contains those files which are required frequently when a Laravel project is running.

It contains the following folders:

1. App: It contains the files which are called frequently.
2. Framework: It contains templates, filed based sessions, and file cache.
3. Logs: This folder tracks the exceptions and error logs.

Test directory
holds all the automated unit test cases

Vendor directory
contains the composer dependencies

The route/web.php directory contains the definition of route files for your web interface. The routes in web.php are assigned with the web middleware group that provides the features like session state and CSRF protection. The routes defined in routes/api.php are assigned with the API middleware group, and they are stateless.
The routes defined in the routes/web.php can be accessed by entering the defined URL to the browser.

Route is the class which defines the static method get(). The get() method contains the parameters '/' and function() closure. The '/' defines the root directory and function() defines the functionality of the get() method.

<?php  
Route::get('/', function ()  
 {      
return view ('welcome');  
});  


<?php  
Route::get('/example', function ()  
 {      
return "Hello javaTpoint";  
});  


CSRF Protection
The HTML forms that are pointing to Post, Put or Delete routes defined in the web route files should include CSRF token field. If the CSRF token field is not included, then the request will be rejected.

<form method="POST" action="/profile">  
    @csrf  
    ...  
</form>  

The router defines the routes that can respond to the following http verbs:

Route::get($uri, $callback);

Route::post($uri, $callback);

Route::put($uri, $callback);

Route::patch($uri, $callback);

Route::delete($uri, $callback);

Route::options($uri, $callback);

to register a route that responds to the multiple http verbs, and this can be achieved by using the match() method.
Route::match(['get', 'post'], '/', function () {  
//  
}); 

to register a node that responds to all the http verbs, so we use any() method.
Route::any('/', function ()   
{  
//  
}) 

Redirect() method is used to navigate from one URL to another URL
<?php  
Route::get('hello', function () {  
    return redirect('/');  
})  

<?php  
Route::redirect('hello','/');  

View() method is used to return the view of another URL.
<?php  
Route::get('/', function () {  
    return view('welcome');  
});  
<?php  
Route::view('/','welcome');  



Required Parameters
<?php  
Route::get('/', function()  
{  
  return "This is a home page";   
}  
);  
Route::get('/about', function()  
{  
  return "This is a about us page";   
}  
);  
Route::get('/contact', function()  
{  
  return "This is a contact us page";   
}  
);


Route::get('/post/{id}', function($id)  
{  
  return "id number is : ". $id;   
}  
);  

 
Route::get('/post/{id}/{name}', function($id,$name)  
{  
  return "id number is : ". $id ." ".$name;   
}  
);  

Route::get('user/{name?}', function ($name=null) {  
    return $name;  
});  

Route::get('user/{name?}', function ($name = 'himani') {  
    return $name;  
});  

Route::get('user/{name?}', function ($name=null) {  
    return $name;  
})->where('name','[a-zA-Z]+');  

The 'where' method accepts the name of the parameter and regular expression constraint that defines how the parameter should be constrained.

Route::get('user/{id?}', function ($id=null) {  
    return "id is : ". $id;  
}->where('id','[0-9]+');  

Route::get('user/{id}/{name}', function ($id,$name) {  
    return "id is : ". $id ." ,".  "Name is : ".$name ;  
})->where(['id'=>'[0-9]+', 'name'=>'[a-zA-Z]+']);  

Global Constraints are used when we have multiple routes, and the same constraints are applied to all the routes.define these patterns in the boot method of your RouteServiceProvider.
public function boot()  
{  
Route::pattern('id', '[0-9]+');  
parent::boot();  
}  

Named Routes
Route::get('student/details', function()  
{  
    //  
}) -> name('student_details'); 

Route::get('student/details', 'studentcontroller@showdetails') -> name('student_details');

Generating URLs to named routes
//Generating URLs  
$url= route('student_details');  
//Generating Redirects...  
return redirect() -> route('student_details');  


Route::get('student/details/example',array   
('as'=>'student.details',function()  
{  
   $url=route('student.details');  
   return "The url is : " .$url;  
}));  

php artisan route:list.==>command to know route lists

Note: The benefit of using named routes is that if we change the location of the route, then also the link will work or we can say that it is beneficial for changing the URLs dynamically.

Route::get('user/{id}/profile',function($id)  
{  
   $url=route('profile',['id'=>100]);  
    return $url;  
})->name('profile');  

Navigating from one route to another using named routes
<a href="{{ route('student.details') }}">Student</a>  

Middleware acts as a layer between the user and the request. located in the app/Http/Middleware directory.

Creating a middleware
command:php artisan make:middleware 'name of the middleware'.

Apply a Middleware
1.Open the kernel.php file. If we want to apply the middleware to all the URLs.

protected $middleware =[]

2.Open the kernel.php file. If we want to apply the middleware to some specific routes

protected $routeMiddleware = [ ]

3. Open the kernel.php file. If we want to apply group of middlewares at a time 

protected $middlewareGroups = [ ]

Add the middleware code in the web.php file.
Route::Get('/',function()  
{  
  return view('welcome');  
})-> middleware('age');  

Route::Get('/{age}',function($age)  
{  
  return view('welcome');  
})-> middleware('age');  


public function handle($request, Closure $next){  
  //return "middleware";  
if($request->age>10)  
{  
echo "Age is greater than 10";  
}  
else  
{  
echo"Age is not greater than 10";  
}  
return $next($request);       
}}

Route Groups is an essential feature in Laravel, which allows you to group all the routes. Routes Groups are beneficial when you want to apply the attributes to all the routes. If you use route groups, you do not have to apply the attributes individually to each route; this avoids duplication. It allows you to share the attributes such as middleware or namespaces, without defining these attributes on each individual route.
Route::group( [ ] , callback);  

Route::group([], function()  
{  
   Route::get('/first',function()  
 {  
   echo "first route";  
 });  
Route::get('/second',function()  
 {  
   echo "second route";  
 });  
Route::get('/third',function()  
 {  
   echo "third route";  
 });  
});  


Path prefixes are used when we want to provide a common URL structure.
Route::group(['prefix' => 'tutorial'], function()  
{  
   Route::get('/aws',function()  
 {  
   echo "aws tutorial";  
 });  
Route::get('/jira',function()  
 {  
   echo "jira tutorial";  
 });  
Route::get('/testng',function()  
 {  
   echo "testng tutorial";  
 });  
});  


We can also assign middleware to all the routes within a group.

Route::middleware(['age'])->group( function()  
{  
  
   Route::get('/aws',function()  
 {  
   echo "aws tutorial";  
 });  
Route::get('/jira',function()  
 {  
   echo "jira tutorial";  
 });  
Route::get('/testng',function()  
 {  
   echo "testng tutorial";  
 });  
  
});  


The name method is used to prefix each route name with some specified string

Route::name('admin.')->group(function()  
{  
   Route::get('users', function()  
{  
 return "admin.users";  
})->name('users');  
});  


Controllers are used to handle the request logic within the single class, and the controllers are defined in the "app/http/Controllers" directory
php artisan make:Controller PostsController


php artisan make:controller --resource PostController (predefined functions)

1.create(): It is used to create a new resource.

2.store(): It is used to store the specified resource.

3.update(): It is used to update the specified resource in the storage.

4.destroy(): It is used to remove the specified resources from the storage.

routing controller==>Route::get('/post','PostController@index');  

passing data to controller:
Route::get('/post/{id}','PostController@index');

public function index($id)  
{  
    return "ID is :". $id;  
}  


As RouteServiceProvider loads all the route files that contain the namespace, we just need to specify the class name that comes after the App/Http/Controllers portion of the namespace.
Route::get('\post','Post\PostController@index');


If we want to use the single method in a controller, then we can use the single __invoke() method on the controller.
route::get('/post/{id}','PostController');  
class PostController extends Controller  
{  
    //  
 public function __invoke($id)  
{  
  return "id is : ". $id;  
}  
}  
This concludes that we do not need to write the @invoke method for accessing the single action controllers.

If no action is specified, i.e., we forget to write the __invoke() method, then the UnexpectedValueExpression is thrown.


Laravel resource controllers provide the CRUD routes to the controller in a single line of code. A resource controller is used to create a controller that handles all the http requests stored by your application.

The resource() is a static function like get() method that gives access to multiple routes that we can use in a controller.

Route::resource('posts','PostController');

creating a resource controller: php  artisan make:controller PostController -resource;  

<?php  
namespace App\Http\Controllers;  
use Illuminate\Http\Request;  
class PostController extends Controller  
{  
    /** 
     * Display a listing of the resource. 
     * @return \Illuminate\Http\Response 
     */  
public function index()  
{  
          
//  
      
}  
/** 
     * Show the form for creating a new resource. 
     * @return \Illuminate\Http\Response 
       
*/  
 public function create()  
{  
          
//  
      
}  
/** 
     * Store a newly created resource in storage. 
     * 
     * @param  \Illuminate\Http\Request   $request 
     * @return \Illuminate\Http\Response 
     */  
public function store(Request $request)  
{  
          
//  
      
}  
/** 
     * Display the specified resource. 
     * @param  int  $id 
     * @return \Illuminate\Http\Response 
     */  
public function show($id)  
{  
  
  //  
}  
/** 
     * Show the form for editing the specified resource. 
     * @param  int  $id 
     * @return  \Illuminate\Http\Response 
     */  
 public function edit($id)  
      
{  
          
//  
      
}  
/** 
     * Update the specified resource in storage. 
     * @param  \Illuminate\Http\Request   $request 
     * @param  int  $id 
     * @return \Illuminate\Http\Response 
     */  
 public function update(Request $request, $id)  
{  
          
//  
      
}  
/** 
     * Remove the specified resource from storage. 
     * @param  int  $id 
     * @return  \Illuminate\Http\Response 
     */  
 public function destroy($id)  
 {  
          
//}}  


Accessing the show() method of PostController class
public function show($id)  
{  
return "show method is called and ID is : ". $id;  
}  

As we know that URI of the posts.show is posts/{posts},
'localhost/laravelproject/public/posts/58'

Accessing the create() method of PostController class
public function create()  
{  
     return "This is the create method";  
}  

As we know that the URI of the posts.create is posts/create, so the URL to access the create() method would be 'localhost/laravelproject/public/posts/create'.

We can register the routes for multiple controllers by passing an array to the resources() method.

route::resources(  
['posts'=>'PostController',  
'student'=>'StudentController']  
);  


Partial Resource Routes
Route::resource('student','StudentController',['only' => ['create','show']]);  

All the methods of the controller have a default route name, but Laravel allows you to override the route names by passing name array. Name array contains the name of the routes that you want to specify of your choice.

Route::resource('student', 'StudentController',['names' => ['create' =>'student.build']]);  















