              LARAVEL FRAMEWORK SHORT NOTES
================================================================
check version of laravel framework installed in the systems
==>php artisan --version

check version of composer installed in the systems
==>composer

create laravel app in a directory
==>composer create-project laravel/laravel â€“prefer-dist

start laravel app in local server
==>php artisan serve

laravel development server will start at localhost:8000

to generate application key to secure session and other encrypted data
==>php artisan key:generate

to rename the laravel application name
==>php artisan app:name "new name"

to start maintainence mode
==>php artisan down

to stop maintainence mode
==>php artisan up

to print component output using component name
--><x-header componentName="nameofcomponent">

create a middleware with some addition functions
==>php artisan make:middleware nameofmiddleware --plain

application key can be seen inside .env file

Laravel is a PHP framework that uses the MVC architecture.

Framework: It is the collection of methods, classes, or files that the programmer uses, and they can also extend its functionality by using their code.
Architecture: It is the specific design pattern that the framework follows. Laravel is following the MVC architecture.

M: 'M' stands for Model. A model is a class that deals with a database.
V: 'V' stands for View. A view is a class that deals with an HTML
C: 'C' stands for Controller. A controller is the middle-man that deals with both model and view. A controller is the class that retrieves the data from the model and sends the data to the view class.

================================================================
                ADVANTAGES OF LARAVEL FRAMEWORK:
================================================================

1.Creating authorization and authentication systems
2.Integration with tools
Laravel is integrated with some popular cache back ends such as Redis, and Memcached.
3.Mail service integration
4.Handling exception and configuration error
5.Automation testing work
6.Separation of business logic code from presentation code
7.Fixing most common technical vulnerabilities
An American organization, i.e., OWASP Foundation, defines the most important security vulnerabilities such as SQL injection, cross-site request forgery, cross-site scripting, etc.
8.Scheduling tasks configuration and management

================================================================
                     FEATURE OF LARAVEL:
================================================================

1.Authentication
2.Innovative Template Engine
3.Effective ORM
4.MVC Architecture Support
5.Secure Migration System
6.Unique Unit-testing
7.Intact Security
It uses "Bcrypt Hashing Algorithm" to generate the salted password means that the password is saved as an encrypted password in a database, not in the form of a plain text.
8.Libraries and Modular
9.Artisan

Artisan also allows the developers to create their own commands.
================================================================
                            COMPOSER:
================================================================

Composer is a dependency manager for a PHP programming language that manages the dependencies of PHP software and required libraries
Composer runs through the command line. The main purpose of the composer is to install the dependencies or libraries for an application. The composer also provides the users to install the PHP applications available on the Packagist, where Packagist is the main repository that contains all the available packages.

Following are some important commands used in Composer:
1.The require command is used to add the libraries or packages as a parameter to the file composer.json, and then install it.
2.The install command is used to install all the libraries or packages from the composer.json file. This command is used to download all the PHP dependency repositories from the composer.json file.
3.The update command is used to update all the libraries or packages from the composer.json file based on the versions mentioned in the composer.json file.
4.The remove command is used to uninstall the library or package and remove it from the composer.json file.

check whether the composer is installed successfully or not. To check this, open the command prompt and type Composer then press enter.

command to create a new laravel project:
-->composer create-project laravel/laravel project_name   (for latest laravel version)
or
-->composer create-project ?prefer-dist laravel/laravel project_name 5.2.29  (for old laravel versions)
================================================================
                    LARAVEL DIRECTORY STRUCTURE:
================================================================

1.APP directory

The App folder contains the following sub-folders:
1.Console = Console folder contains the artisan commands required for Laravel.
2.Exceptions = Exceptions folder contains the various exception handlers.The Exceptions directory contains the file handle.php that handles all the exceptions.
3.Http = It has sub-folders such as controllers, middleware, and requests.
    1. middleware = It provides a filter mechanism and communication between request and response.
    2. Requests = includes all the requests of an application.
4.Providers =contain all the service providers that are required to register events for core servers and provides configuration for Laravel application.
------------------------------------------------------------
2.BOOTSTRAP directory

holds the files that are required to bootstrap the Laravel application and to configure auto-loading. 
The bootstrap folder contains a sub-folder cache used for caching a web application. 
It also contains the file app.php that initializes the scripts required for bootstrap.
------------------------------------------------------------
3.CONFIG directory

contains the various configuration files
------------------------------------------------------------
4.DATABASE directory

holds the database files.

database directory consists of three sub-folders:
1.FACTORIES: The factories folder is used to generate a huge number of data records.
2.MIGRATION: The migrations folder is used to migrate the database in web application.
3.SEEDS: The seeds folder contains the classes used to perform unit testing database.
------------------------------------------------------------
5.PUBLIC directory

contains the front controllers used for initializing the Laravel web application

Following are the sub-folders of a public directory:
1. .HTACCESS: It is used for the server configuration.
2. JS and CSS: These files are considered as the main assets of a web application.
3. INDEX.php: This file is used for initializing the web application.
------------------------------------------------------------
6.RESOURCE directory

used to enhance the web application. 

It contains the following sub-folders:

1. ASSETS: This folder contains the files such as LESS and SCSS used for styling the web application.
2. LANG: The lang folder provides configuration for localization or internationalization.
3. VIEWS: The views folder contains html files used to interact with the end-users
------------------------------------------------------------
7.STORAGE Directory

contains those files which are required frequently when a Laravel project is running.

It contains the following folders:

1. APP: It contains the files which are called frequently.
2. FRAMEWORK: It contains templates, filed based sessions, and file cache.
3. LOGS: This folder tracks the exceptions and error logs.

------------------------------------------------------------
8.TEST directory

holds all the automated unit test cases

------------------------------------------------------------
9.VENDOR directory

contains the composer dependencies

============================================================

The route/web.php directory contains the definition of route files for your web interface. 
The routes in web.php are assigned with the web middleware group that provides the features like session state and CSRF protection. 
The routes defined in routes/api.php are assigned with the API middleware group, and they are stateless.
The routes defined in the routes/web.php can be accessed by entering the defined URL to the browser.

Route is the class which defines the static method get(). The get() method contains the parameters '/' and function() closure. The '/' defines the root directory and function() defines the functionality of the get() method.

<?php  
Route::get('/', function ()  
 {      
return view ('welcome');  
});  


<?php  
Route::get('/example', function ()  
 {      
return "Hello javaTpoint";  
});  


CSRF Protection
The HTML forms that are pointing to Post, Put or Delete routes defined in the web route files should include CSRF token field. If the CSRF token field is not included, then the request will be rejected.
<form method="POST" action="/profile">  
    @csrf  
    ...  
</form>  
class formcontroller extends controller{
  function get_form_data(Request $req){
    return $req->input();  //to return form data in json format data with csrf token
  }
}


The router defines the routes that can respond to the following http verbs:

Route::get($uri, $callback);

Route::post($uri, $callback);

Route::put($uri, $callback);

Route::patch($uri, $callback);

Route::delete($uri, $callback);

Route::options($uri, $callback);

to register a route that responds to the multiple http verbs, and this can be achieved by using the match() method.
Route::match(['get', 'post'], '/', function () {  
//  
}); 

to register a node that responds to all the http verbs, so we use any() method.
Route::any('/', function ()   
{  
//  
}) 

Redirect() method is used to navigate from one URL to another URL
<?php  
Route::get('hello', function () {  
    return redirect('/');  
})  

<?php  
Route::redirect('hello','/');  

View() method is used to return the view of another URL.
<?php  
Route::get('/', function () {  
    return view('welcome');  
});  
<?php  
Route::view('/','welcome');  



Required Parameters
<?php  
Route::get('/', function()  
{  
  return "This is a home page";   
}  
);  
Route::get('/about', function()  
{  
  return "This is a about us page";   
}  
);  
Route::get('/contact', function()  
{  
  return "This is a contact us page";   
}  
);


Route::get('/post/{id}', function($id)  
{  
  return "id number is : ". $id;   
}  
);  

 
Route::get('/post/{id}/{name}', function($id,$name)  
{  
  return "id number is : ". $id ." ".$name;   
}  
);  

Route::get('user/{name?}', function ($name=null) {  
    return $name;  
});  

Route::get('user/{name?}', function ($name = 'himani') {  
    return $name;  
});  

Route::get('user/{name?}', function ($name=null) {  
    return $name;  
})->where('name','[a-zA-Z]+');  

The 'where' method accepts the name of the parameter and regular expression constraint that defines how the parameter should be constrained.

Route::get('user/{id?}', function ($id=null) {  
    return "id is : ". $id;  
}->where('id','[0-9]+');  

Route::get('user/{id}/{name}', function ($id,$name) {  
    return "id is : ". $id ." ,".  "Name is : ".$name ;  
})->where(['id'=>'[0-9]+', 'name'=>'[a-zA-Z]+']);  

Global Constraints are used when we have multiple routes, and the same constraints are applied to all the routes.define these patterns in the boot method of your RouteServiceProvider.
public function boot()  
{  
Route::pattern('id', '[0-9]+');  
parent::boot();  
}  

Named Routes
Route::get('student/details', function()  
{  
    //  
}) -> name('student_details'); 

Route::get('student/details', 'studentcontroller@showdetails') -> name('student_details');

Generating URLs to named routes
//Generating URLs  
$url= route('student_details');  
//Generating Redirects...  
return redirect() -> route('student_details');  


Route::get('student/details/example',array   
('as'=>'student.details',function()  
{  
   $url=route('student.details');  
   return "The url is : " .$url;  
}));  

php artisan route:list.==>command to know route lists

Note: The benefit of using named routes is that if we change the location of the route, then also the link will work or we can say that it is beneficial for changing the URLs dynamically.

Route::get('user/{id}/profile',function($id)  
{  
   $url=route('profile',['id'=>100]);  
    return $url;  
})->name('profile');  

Navigating from one route to another using named routes
<a href="{{ route('student.details') }}">Student</a>  

Middleware acts as a layer between the user and the request. located in the app/Http/Middleware directory.

Creating a middleware
command:php artisan make:middleware 'name of the middleware'.

Apply a Middleware
1.Open the kernel.php file. If we want to apply the middleware to all the URLs.

protected $middleware =[]

2.Open the kernel.php file. If we want to apply the middleware to some specific routes

protected $routeMiddleware = [ ]

3. Open the kernel.php file. If we want to apply group of middlewares at a time 

protected $middlewareGroups = [ ]

Add the middleware code in the web.php file.
Route::Get('/',function()  
{  
  return view('welcome');  
})-> middleware('age');  

Route::Get('/{age}',function($age)  
{  
  return view('welcome');  
})-> middleware('age');  


public function handle($request, Closure $next){  
  //return "middleware";  
if($request->age>10)  
{  
echo "Age is greater than 10";  
}  
else  
{  
echo"Age is not greater than 10";  
}  
return $next($request);       
}}

Route Groups is an essential feature in Laravel, which allows you to group all the routes. 
Routes Groups are beneficial when you want to apply the attributes to all the routes. 
If you use route groups, you do not have to apply the attributes individually to each route; this avoids duplication. 
It allows you to share the attributes such as middleware or namespaces, without defining these attributes on each individual route.

Route::group( [ ] , callback_function);  

Route::group([], function()  
{  
   Route::get('/first',function()  
 {  
   echo "first route";  
 });  
Route::get('/second',function()  
 {  
   echo "second route";  
 });  
Route::get('/third',function()  
 {  
   echo "third route";  
 });  
});  


Path prefixes are used when we want to provide a common URL structure.
Route::group(['prefix' => 'tutorial'], function()  
{  
   Route::get('/aws',function()  
 {  
   echo "aws tutorial";  
 });  
Route::get('/jira',function()  
 {  
   echo "jira tutorial";  
 });  
Route::get('/testng',function()  
 {  
   echo "testng tutorial";  
 });  
});  


We can also assign middleware to all the routes within a group.

Route::middleware(['age'])->group(function(){    
    Route::get('/aws',function(){  
      echo "aws tutorial";  
    });  
    Route::get('/jira',function(){
      echo "jira tutorial";  
    });  
    Route::get('/testng',function(){  
      echo "testng tutorial";  
    });  
});  


The name method is used to prefix each route name with some specified string

Route::name('admin.')->group(function()  
{  
   Route::get('users', function()  
{  
 return "admin.users";  
})->name('users');  
});  


Controllers are used to handle the request logic within the single class, and the controllers are defined in the "app/http/Controllers" directory
php artisan make:Controller PostsController


php artisan make:controller --resource PostController (predefined functions)

1.create(): It is used to create a new resource.

2.store(): It is used to store the specified resource.

3.update(): It is used to update the specified resource in the storage.

4.destroy(): It is used to remove the specified resources from the storage.

routing controller==>Route::get('/post','PostController@index');  

passing data to controller:
Route::get('/post/{id}','PostController@index');

public function index($id)  
{  
    return "ID is :". $id;  
}  


As RouteServiceProvider loads all the route files that contain the namespace, we just need to specify the class name that comes after the App/Http/Controllers portion of the namespace.
Route::get('\post','Post\PostController@index');


If we want to use the single method in a controller, then we can use the single __invoke() method on the controller.
route::get('/post/{id}','PostController');  
class PostController extends Controller  
{  
    //  
 public function __invoke($id)  
{  
  return "id is : ". $id;  
}  
}  
This concludes that we do not need to write the @invoke method for accessing the single action controllers.

If no action is specified, i.e., we forget to write the __invoke() method, then the UnexpectedValueExpression is thrown.


Laravel resource controllers provide the CRUD routes to the controller in a single line of code. A resource controller is used to create a controller that handles all the http requests stored by your application.

The resource() is a static function like get() method that gives access to multiple routes that we can use in a controller.

Route::resource('posts','PostController');

creating a resource controller: php  artisan make:controller PostController -resource;  

<?php  
namespace App\Http\Controllers;  
use Illuminate\Http\Request;  
class PostController extends Controller  
{  
    /** 
     * Display a listing of the resource. 
     * @return \Illuminate\Http\Response 
     */  
public function index()  
{  
          
//  
      
}  
/** 
     * Show the form for creating a new resource. 
     * @return \Illuminate\Http\Response 
       
*/  
 public function create()  
{  
          
//  
      
}  
/** 
     * Store a newly created resource in storage. 
     * 
     * @param  \Illuminate\Http\Request   $request 
     * @return \Illuminate\Http\Response 
     */  
public function store(Request $request)  
{  
          
//  
      
}  
/** 
     * Display the specified resource. 
     * @param  int  $id 
     * @return \Illuminate\Http\Response 
     */  
public function show($id)  
{  
  
  //  
}  
/** 
     * Show the form for editing the specified resource. 
     * @param  int  $id 
     * @return  \Illuminate\Http\Response 
     */  
 public function edit($id)  
      
{  
          
//  
      
}  
/** 
     * Update the specified resource in storage. 
     * @param  \Illuminate\Http\Request   $request 
     * @param  int  $id 
     * @return \Illuminate\Http\Response 
     */  
 public function update(Request $request, $id)  
{  
          
//  
      
}  
/** 
     * Remove the specified resource from storage. 
     * @param  int  $id 
     * @return  \Illuminate\Http\Response 
     */  
 public function destroy($id)  
 {  
          
//}}  


Accessing the show() method of PostController class
public function show($id)  
{  
return "show method is called and ID is : ". $id;  
}  

As we know that URI of the posts.show is posts/{posts},
'localhost/laravelproject/public/posts/58'

Accessing the create() method of PostController class
public function create()  
{  
     return "This is the create method";  
}  

As we know that the URI of the posts.create is posts/create, so the URL to access the create() method would be 'localhost/laravelproject/public/posts/create'.

We can register the routes for multiple controllers by passing an array to the resources() method.

route::resources(  
['posts'=>'PostController',  
'student'=>'StudentController']  
);  


Partial Resource Routes
Route::resource('student','StudentController',['only' => ['create','show']]);  

All the methods of the controller have a default route name, but Laravel allows you to override the route names by passing name array. Name array contains the name of the routes that you want to specify of your choice.

Route::resource('student', 'StudentController',['names' => ['create' =>'student.build']]);  

======================================================
                  laravel forms
======================================================

install a html package from composer
==>$composer require "laravelcollective/html":"^5.4.0"  

open the config/app directory in your project and add the html provider in the providers array of the config/app.php file.

we add the two class aliases to the aliases array of the config/app.php file.
'aliases' => [  
              'Form' => Illuminate\Html\FormFacade::class,  
              'Html' => Illuminate\Html\HtmlFacade::class,   
             ],  

Opening a Form
==>
Form::open(['url' => 'post/create'])  
//  
//
//
Form::close()

In laravel forms, the default method is assumed to be 'post' method
==>Form::open(['url'=>'Post/create , 'method'=>'Put''])
or
==>Form.open(['route' => 'route.name'])  
or
==>Form.open(['action' => 'Controller@method' , 'method'=>'POST' ])  

The syntax for writing a label element in Laravel is given below:
==>Form::label('phone_no', 'Phone Number',['class'=>'phone_no']);

The syntax for generating a text area in Laravel is given below:
==>Form::text('email');
or
We can also specify the default value to the text box.
==>Form::text('email','akshita123@gmail.com');

The syntax for the password field is given below:
==>Form::password('password',['class'=>'pass']);

We can create the checkbox as given below:
==>Form::checkbox('name','value');

By default, the checkbox is unchecked. We can also check the box by providing true value to the checkbox element.
==>Form::checkbox('name','value',true);

We can create the radio button as given below:
==>Form::radio('name','value');

By default, the radio button is not selected. We can also select the radio button by providing true value to the radio button element.
==>Form::radio(''name','value',true);

We can also add the number input field in a form.
==>Form::number('name','value');

Syntax for file input field is given below:
==>Form::file('image');

The syntax for creating a drop-down menu is given below:
==>Form::select('digits', [1,2,3,4,5,6])

We can also set the drop-down list with a default value:
==>Form::select('digits',[1,2,3,4,5,6],'2')
The above code sets the value of the drop-down list with a second element of the array, i.e., 3 as indexing starts with 0.

Generating Grouped list
==>Form::select('name',[
        'fruits' => ['Apple','Mango','Orange'],
        'Vegetables' => ['Potato','Tomato','Cabbage'],
])

Generating drop-down list with a range.
==>Form::selectRange('number',1,30)

Generating drop-down list with a month names.
==>Form.selectMonth('month')

The syntax for generating a date input field is given below:
==>Form::date('name',\Carbon\Carbon::now())

We can also create the button in a web form by using the button field in a form.
==>Form::submit('Click me!!')

for example
==>
{!! Form::open(['route'=>'posts.store']) !!}  
    
<div class="form-group">  
{{form::label('name','Name')}}  
{{form::text('name','',['class'=>'form-control','placeholder'=>'Name'])}}  
</div>  

<div class="form-group">  
{{form::label('gender','Gender')}}  
{{form::radio('male','Male')}} Male  
{{form::radio('Female','Female')}} Female  
</div>  

<div class="form-group">  
{{form::label('profile','Profile')}}  
{{form::select('list',['Software Developer','QA Analyst','Manager','HR'])}}  
</div>  

<div class="form-group">  
{{form::label('dob','Date of Birth')}}  
{{Form::date('dob', \Carbon\Carbon::now())}}  
</div>  

<div class="form-group">  
{{form::label('skills','Skills Description')}}    
{{form::textarea('body','',['placeholder'=>'Skills Description'])}}  
</div>  

<div class="form-group">  
{{form::label('percentage','Percentage in 12th')}}  
{{form::text('percent','',['class'=>'form-control','placeholder'=>'Percentage in 12th'])}}  
</div>  

<div class="form-group">  
{{form::label('experience','Experience')}}  
{{form::number('exp','number')}}  
</div>  

<div class="form-group">  
{{form::label('expected_salary','Expected Salary')}}  
{{form::text('salary','',['placeholder'=>'Expected Salary'])}}  
</div>  
  
<div class="form-group">  
{{form::label('resume','Resume Upload')}}  
{{Form::file('resume')}}  
</div>  
  
{{Form::submit('Submit', ['class'=>'btn btn-primary'])}}  
  
{!!Form::close()!!}  
@stop  

then we make a resource controller to validate form data
==>public function store(Request $request)  
    {  
       $this->validate($request,[  
       'name'=>'required',  
       'list'=> 'required',  
       'dob'=>'required',  
       'body'=>'required',  
       'percent'=>'required',  
       'exp'=>'required',  
       'salary'=>'required',  
       'resume'=>'required']);  
           
      return "Resume has been updated successfully";      
    }  




================================================================
			                    notes
================================================================

2. composer.json file also contains details of the project
 
   "php": "^7.3|^8.0",(min. supported version | current version)

3. Axios: Axios is a Javascript library used to make HTTP requests from node.js or XMLHttpRequests from the browser and it supports the Promise API that is native to JS ES6. It can be used intercept HTTP requests and responses and enables client-side protection against XSRF. It also has the ability to cancel requests.

<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

4. laravel breeze authentication

5. faker.js to create fake data

6. 

7. dd($request); dump and die function to check requests

8. naming conventions:
	
  functions names
  ==>userDetails()
	controller
  ==>FetchController.php
	models
  ==>Home.php,FetchModal.php
	blade files
  ==>show_user_details.blade.php
	javascript files
  ==>show_users.js
	route names
  ==>update_pro_name
	route url
  ==>update-pro-name

-------------------------------------------------------
laravel codes

1.call controller function using url passing parameter

use App\Http\Controllers\ProvisionServer;
Route::get('/user/{id}', [UserController::class, 'show']);

2.


------------------------------------------------------
to use php variable inside js to convert array into json format into view
0.<script>
    var data = @json($data);
    console.log(data[0]);
  </script>

1.@extends( 'home' )===>

2.@section('pageTitle')===>
	{{ 'Enquiry' }}===>
  @endsection===>
		
  @section( 'addtional_css' )===>
	
  @section('content')===>

3.href="{{ asset('https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css')}}"===>
  href="{{ asset('css/new_css/add-enquiry.css')}}"===>

4.@parent===>

5.@append====>

6.href="{{route('enquiry')}}"===>to route using route name

7.@include('enquiry.add.personal')===>to include blade files into current view

8.token: "{{ csrf_token() }}"===>auto generate csrf token for form

9.fetchCountries: "{{ url('fetchCountries') }}"===>

10.pathToEmailAttachment: "{{ asset('uploads/emailtemplate/') }}"===>to add css,js etc files

11.var broadAndNarrowId = {!! json_encode($broadAndNarrowId) !!};===>

12.$('.passport-div-open1, .passport_tentative_date,.passport_tentative_date1  ').hide();===>

13.$("#state_id").append("<option value=\"" + "" + "\">" + "" + "</option>");===>

14.<script src="{{ asset('js/theia-sticky-sidebar.js')}}"></script>===>

15.$('[data-toggle="tooltip"]').tooltip();==>

16.<script>
  $(function () {
    setTimeout(function () {
        var header_height = $("header").height() + 50;
        //  console.log(header_height);
        $(".fixed-scroll-div").length > 0 &&
            $(".fixed-scroll-div").parent().theiaStickySidebar({
                updateSidebarHeight: !0,
                additionalMarginTop: header_height,
            });
    }, 200);
  });
</script>


17.function scrollToAnchor(aid) {
  var aTag = $("a[name='" + aid + "']");
  $('html,body').animate({
    scrollTop: aTag.offset().top - 110
  }, 'slow');
}

$("#1").click(function() {
  scrollToAnchor('perinfo');
});


18. {{ Form::select('marital_status',config('sc_common.marital_status'), isset($personalDetail['marital_status']) ?$personalDetail['marital_status'] : null, ['id' => 'marital_status','class'=>'form-control select2']) }}

{{Form::select('mobile_code',$phoneCode,91, ['class'=>'form-control ISD_code select2','id'=>'mobile_code','placeholder'=>''])}}

{{Form::select('whatsup_no_code',$phoneCode,91, ['class'=>'form-control ISD_code select2','id'=>'whatsup_mobile_code','placeholder'=>''])}}

{{Form::select('secondary_mobile_code',$phoneCode,91, ['class'=>'form-control ISD_code select2','placeholder'=>''])}}

{{Form::select('country_live_in',$allCountry,101, ['class'=>'form-control select2','id'=>'country_id','placeholder'=>'','onchange'=>'get_addStateName();'])}}

{{Form::select('state_id',$indianState,null, ['class'=>'form-control select2','id'=>'state_id','onchange'=>"get_addCityName()"])}}


19. value="{{ isset($spouse['marriage_date'])?$spouse['marriage_date']:null }}"

20. $('#marriage_date').datepick({
        dateFormat: 'dd-mm-yyyy',
        maxDate: 0,
    });

21.onkeypress="return isNumberKey(event)

22.


---------------------------------------------------------
			blade template note

//to print variable value in the template view
{{$variable}};  

//to print variable value after checking exsistence
{{ $variable or 'default value'}}  

//check if a variable has value
@isset($a)
  template code
@endisset


@if(($id)==1)  
student id is equal to 1.  
@else  
student id is not equal to 1  
@endif  


@unless($id==1)  
student id is not equal to 1.  
@endunless  


@hasSection('title')  
 @yield('title') - App Name  
 @else  
 Name  
@endif  



@for($i=1;$i<11;$i++)  
{{$i}}  
@endfor  


@forelse($students as $student)  
{{$student}}<br>
@empty
No Record Found  
@endforelse  



@foreach($students as $student)  
{{$student}}<br>  
@endforeach  


@while(($i)<5)  
javatpoint  
{{$i++}}  
@endwhile  



@yield('content')  
@yield('footer') 

@extends('layout.master')  

@section('content')  
<h1>Contact Page </h1>   
@stop  

@section('footer')  
<script> alert("Hello JavaTpoint") </script>      
@stop 

@extends('layout.master')  
@section('content')  
<h1>Post Page:</h1>  
<h2>id is :{{$id}}<br> Password is :{{$password}}<br>Name is : {{$name}}</h2>  
@stop  

@extends('layout.master')  
@section('content')  
<h1>Contact Page</h1>  
@stop   
@section('footer')  
@parent  
<p>this is appended</p>  
@stop  


The use of @parent directive is to display the content of the section defined in the master layout.

=======================================================================
                    migration files functions
=======================================================================

  public function up()  
    {  
            Schema::create('users', function (Blueprint $table) {  
            $table->bigIncrements('id');  
            $table->string('name');  
            $table->string('email')->unique();  
            $table->timestamp('email_verified_at')->nullable();  // value can be null if not filled
            $table->string('password');  
            $table->rememberToken();  //generate unique token id for users after login
            $table->timestamps();  //generate created_at and updated_at time column
        });  
    }  
  
  public function down()  
    {  
        Schema::dropIfExists('users');  
        
        //This function checks whether the 'users' table exists or not, if the 'users' exists, then it drops the users table.
    }  


up() method is used to create the new table, add the new columns or indexes to the database
down() method is the opposite of the up() method, i.e., it drops the fields. 
The above class is basically creating the table in a database. 
The up() method runs the static method, i.e., create() by using the Schema class.
The create() method contains the two parameters, i.e., the name of the table and the closure function.

$table->bigIncrements('id'): It means that the $table is implementing the increments() method which is creating the id column in users table, and this 'id' is auto-incremented.

$table->string('name'): It means that $table implements the string() method which is creating the name column in users table.

$table->string('email')->unique(): It means that $table implements the string() method which is creating the email column in users table. It also implements the unique() function which means that email should be unique.

$table->timestamp('email_verified_at')->nullable(): It means that $table implements the timestamp() method which is creating the email_verified_at column in users table. This function also creates the two columns, i.e., created_at and updated_at, and these two fields are automatically updated when new records are added or updated.

$table->integer('is_admin')->unsigned();
$table->integer('is_admin')->default('0'); 

command to create migration file
==>php artisan make:migration file_name --create="table_name" //'-create="table_name"' Is the flag that creates the table. 

<?php  
use Illuminate\Support\Facades\Schema;  
use Illuminate\Database\Schema\Blueprint;  
use Illuminate\Database\Migrations\Migration;  
class AddColumnAdminIsToTable extends Migration  
{  
    /** 
     * Run the migrations. 
     * 
     * @return void 
     */  
    public function up()  
    {  
        Schema::table('posts', function (Blueprint $table) {  
            //  
        });  
    }  
  
    /** 
     * Reverse the migrations. 
     * 
     * @return void 
     */  
    public function down()  
    {  
        Schema::table('posts', function (Blueprint $table) {  
            //  
        });  
    }  
}  

command to Add columns to the existing table using migration
==>php artisan make:migration file_name -table="table_name"   //-table="table_name" is the flag which tells the laravel that we are working on exsisting table.

command to create tables into database
==>php artisan migrate 


command to rollback tables from the database
==>php artisan migrate:rollback

lists all the commands available in Laravel.
==>php artisan list


There are six commands of migrate in Laravel:
php artisan migrate ==> creates the migration table in a database.
php artisan migrate:refresh ==> rollback all the migrations and then re-run the migrations. Basically, it is used to re-create the entire tables.
php artisan migrate:reset ==> rollback all the migrations, i.e., it drops all the tables that you have created in your database.
php artisan migrate:rollback ==> rollback the last tables batch migration.
php artisan migrate:status ==> to show the status of each migration.

---------------------------------------------------------------------
		DEALING WITH DATABASE

1.Inserting the data

Route::get('/insert', function () {  
	DB::insert('insert into posts(title,body) values(?,?)',['software developer','himanshu is a software developer']);  
}); 


2.Reading the data

Route::get('/select',function(){  
	$results=DB::select('select * from posts where id=?',[1]);  
	foreach($results as $posts)  
	{  
	echo "title is :".$posts->title;  
	echo "<br>";  
	echo "body is:".$posts->body;  
	}  
	}); 

3.Updating the data

Route::get('/update', function(){  
$updated=DB::update('update posts set title="software tester" where id=?',[1]);  

if($updated)  {
echo "updated";
}else{
echo "not updated";
}
});

4.Deleting the data

Route::get('/delete',function(){  
$deleted=DB::delete('delete from posts where id=?',[2]);  
if($deleted)  {
echo "deleted";
}else{
echo "not deleted";
}
});
});  

-------------------------------------------------------------------
			  ELOQUENT

eloquent model that allows the interaction with a database. 
Each database table has its corresponding model that provides the interaction with a database. 
The model allows you to query the data in your tables.

Models are created in the app directory

command to create the model:
==>php artisan make:model model_name

generate the model by using database migration:
==>php artisan make:model model_name -m / php artisan make:model Post -migration

Mostly model class name should be in singular format and table name should be in plural format of model class name....like class table extends Model{} --> table name in the database --> tables

if it is not then declare protected $table = 'table_name' inside model class of that table;

structure of the model class:
<?php  
namespace App;  
use Illuminate\Database\Eloquent\Model;  
class table extends Model  
{  
	protected $table = 'table_1'; // it is used when table name is different from class name else it is not necessery to declare
	protected $primaryKey = 'post_id';  
	public $incrementing = false;
	protected $keyType = 'string';	
}  

fetching all data from the table
<?php  
use App\Post;  

Route::get('/read',function(){  

$posts=model_class_name::all();  //all() method that retrieves all the records from the database

foreach($posts as $post)  
{  
  echo $post->column_name;  
}  
});  

finding data from the table

Route::get('/find',function(){  
$posts=model_class_name::find(2); 	//to retrieve only 2nd row from the database
return $posts->title;  		   

$posts=model_class_name::where('id',2)->first();  //fetch only first row where id=2
return $posts;  

$posts=model_class_name::where('id',1)->value('column_name');  //to retrieve the value of a column directly.
return $posts;  

});  

pluck() method
==>used to retrieve a list of specific values from a given $array. 
It is most useful when used against arrays of objects, but will also work with arrays just as well.
for example:
$country = Country::where('is_active', 1)->pluck('country_name', 'id');

inserting data into database

Route::get('/insert',function(){
$post=new model_class_name;  
$post->column_name_1='Nishka';      //inserting into column_name_1
$post->column_name_2='QA Analyst';  //inserting into column_name_2
$post->save();  		    //to insert data
});  


Route::get('/basicupdate',function(){  
$post=model_class_name::find(2);    	//find 2nd row		   
$post->column_name_1='Haseena';     	//change column value of that row 	
$post->column_name_2='Graphic Designer';//change column value of that row
$post->save();  			//to update data
});  

MASS ASSIGNMENT

Route::get('/create',function(){  
Post::create(['column_name_1'=>'Harshita','column_name_2'=>'Technical Content Writer']);  
});  

To provide the mass assignment, we need to add the $fillable attribute in a model class
<?php  
namespace App;  
use Illuminate\Database\Eloquent\Model;  
class Post extends Model  
{  
    //  
protected $table='posts';  
protected $primaryKey='id';  
protected $fillable=  
[  
'column_name_1',  
'column_name_2'  
];  
}  

mass updating data through eloquent
Route::get('/update',function(){  
model_class_name::where('id',1)->update(['column_name_1'=>'Charu','column_name_2'=>'technical Content Writer']);  
});  

delete data after finding through eloquent
Route::get('/delete',function(){  
$post=model_class_name::find(1);  
$post->delete();  		//delete row after finding
});  


Route::get('/destroy',function(){  
model_class_name::destroy(2);  //direct delete 2nd row
});  


Route::get('/destroy',function(){  
Post::destroy([3,4]);  	       //delete 3rd,4th row directly
});


Route::get('/delete1',function(){  
Post::where('id',5)->delete();  //delete using query
});  

Soft Deleting/Trashing
In soft deleting, records are not permanently deleted; they are stored in the trash space.

First, we need to set the deleted_at attribute to the model class.
<?php  
namespace App;  
use Illuminate\Database\Eloquent\Model;  
use Illuminate\Database\Eloquent\SoftDeletes;  
class Post extends Model  
{  
 use SoftDeletes;  
protected $table='posts';  
protected $primaryKey='id';  
protected $dates=['deleted_at'];  
}  

Now, make migration to add a deleted_at column in the posts table.
php artisan make:migration migration_name --table=table_name


<?php  
use Illuminate\Support\Facades\Schema;  
use Illuminate\Database\Schema\Blueprint;  
use Illuminate\Database\Migrations\Migration;  
  
class AddColumnDeletedAt extends Migration  
{  
    /** 
     * Run the migrations. 
     * 
     * @return void 
     */  
    public function up()  
    {  
        Schema::table('posts', function (Blueprint $table) {  
            $table->softDeletes();  
        });  
    }  
  
    /** 
     * Reverse the migrations. 
     * 
     * @return void 
     */  
    public function down()  
    {  
        Schema::table('posts', function (Blueprint $table) {  
            $table->dropColumn('deleted_at');  
        });  
    }  
}  

The laravel contains the helper method known as softDeletes(), which we have used in the above code. 
The softDeletes() method is used to create the column.

Now, run the command php artisan migrate.

Route::get('/softdelete',function(){  
Post::find(1)->delete();  
});  

we are softdeleting the record

To retrieve the deleted data, we use the withTrashed() method:
Route::get('/readsofdelete',function(){  
$post=model_class_name::withTrashed()->where('id',1)->get();  
return $post;  
});  

Restoring deleted/trashed data:
Route::get('/restore',function(){  
Post::withTrashed()->where('id',1)->restore();  
});  

Deleting records permanently:
Route::get('/forcedelete',function(){  
Post::onlyTrashed()->forceDelete();  
}); 

Laravel Tinker allows you to interact with a database without creating the routes. Laravel tinker is used with a php artisan to create the objects or modify the data. The php artisan is a command-line interface that is available with a Laravel. Tinker is a command tool that works with a php artisan. A tinker plays around the database means that it allows you to create the objects, insert the data, etc.

To enter the Tinker environment, run the command given below:
==>php artisan tinker

inserts the data directly in the database table:
==>$post=App\Post::create(['title'=>'Akshay','body'=>'akshay is a software developer'])

We can retrieve the records from the database in three ways:

The first way is to use the find() method.
==>$post=App\Post::find(1)

The second way is to use the constraint, i.e., where clause.
==>$post=App\Post::where('id',1)->first()

==>$post=App\Post::where('id','>',1)->get()

The third way is to use whereId().
==>$post=App\Post::whereId(1)->first()

Updating data
==>$post=App\Post::find(1)
==>$post->title='Akshay'
==>$post->save()='Akshay'

Deleting data
==>$post->delete()

To delete the record permanently
==>$post->onlyTrashed()

To delete the trashed record permanently
==>$post->forceDelete()

==========================================
              crm notes

1.php carbon class has some predefined functions for time formating
this code will convert string to date using parse method, find difference between both date and convert into years
{{ \Carbon\Carbon::parse($applicantData->date_of_birth)->diff(\Carbon\Carbon::now())->format('%y years') }}

2.config('app.url')
it will go to config file and check for url variable and return env url value from env file if available

3.env('APP_URL', 'http://localhost')
it will return APP_URL value from env file but if it is not available in env value then it will return value as passed in above function as 2nd argument

4.explode(',' , string_variable)
it will break string as per separater passed as first argument in the above function and return array

5.end(pass_array)
return last element of an array

6.except(['name'])
returns collection array except name key

7.array_keys(array)
returns array keys 

8.array_search("value",array)
return key of value in array















































